---
title: "PACHBOARD"
author: "X. Pouwels"
date: "`r paste(Sys.Date())`"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
---

```{r setup, include = FALSE}
library(pacheck)
library(knitr)
library(plotly)
library(ggplot2)
data(df_pa)
```

# Aim (grant application)
The aim of this project is to develop a generic dashboard, e.g. a R shiny application to 1) inspect model inputs and outputs, 2) visualise the original inputs and outputs, 3) investigate the relationship between model inputs and outputs through metamodelling and data visualisation methods, 4) save the performed analyses.

# For info
Package with supporting functions can be found here: https://github.com/Xa4P/pacheck.  
This App should focus on validation of the health economic model (using the probabilistic inputs/ outputs).  

# Structure shiny app
The envisoned R Shiny app will have the following tabs.
I've developed some functions which are ready to be implemented.
Currently, I've only considered 2 strategies ("intervention" (`_in`) and "comparator" (`_comp`)).
What is shown in this document is based on the probabilistic analysis of a (toy) 3-states Health State Transition Model (Progression-free (PF), Progressed disease (PD), Dead (D)) depicted in Figure 1. The intervention is only having an effect on the probability of progression, and incurs costs in the Progression-Free health state.

**Karel**: elke cijfer is een aparte tab van de app.  

## 1.	Upload of original health economic model inputs and outputs
Content:

- Welcome message
- Instructions
- Upload 1 file with inputs and outputs (or 2? inputs and outputs separately?)
- Select variables representing total costs and effects for each strategy (to calculate increments and (incremental) net benefits)

```{r calc_nb, echo = T}
df_pa <- calculate_nb(df = df_pa,
                      e_int = "QALY_int",
                      e_comp = "QALY_comp",
                      c_int = "Costs_int",
                      c_comp = "Costs_comp",
                      wtp = 80000)# calculate net benefits

```

## 2. Investigate model inputs and outputs
### a.	Summary statistics of (user-selected) model inputs and outputs
*To examine whether cost inputs are always positive for instance*

```{r smmr, echo = T}
df <- generate_sum_stats(df_pa)
kable(df)
rm(df)
```

### b.	Correlation matrix inputs (and outputs)
Question Karel:  
- kan dit met kleuren om de sterke van de associatie te onderbouwen?   
```{r corr, echo = T}
generate_cor(df_pa)
```

### c. Inspect types of variables

#### Positive variables
*Are these variables strictly positive?* 
```{r check_positive, echo = T}
check_positive("c_pfs", "c_pd", df = df_pa)
```

#### Variables between 0-1
*Are these variables strictly positive?* 
```{r check_positive2, echo = T}
check_binary("u_pfs", "p_pfspd", df = df_pa)
```

#### Sum of probabilities
*To check whether the sum is lower than or equal to, or equal to 1* 

```{r check_sum, echo = T}
check_sum_probs("p_pfspd", "p_pfsd", df = df_pa, check = "lower") # output is a text
```

### d.	Histogram, density distribution of (user-selected) model inputs and outputs
*To visually investigate the parameter distributions*

#### Single parameter
```{r dist_plot, echo = T}
p_1 <- vis_1_param(df = df_pa,
            param = "u_pfs",
            binwidth = NULL,
            type = "histogram",
            dist = c("norm", "beta", "gamma", "lnorm"))
p_1

paste("Probability to be in user-defined range: ",
      check_range(df_pa,
                  outcome = "u_pfs",
                  min_val = 0.77,
                  max_val = 0.80
                  ), "%") # add this to plot? + lines of min/ max on plot?
```

### Two parameters
```{r vis_2_pars, wcho = T}
p_2p <- vis_2_params(df = df_pa,
                     param_1 = "u_pfs",
                     param_2 = "u_pd",
                     slope = 1,
                     check = "param_2 > param_1")
p_2p
```

### e.	Possibility to fit user-selected distributions (beta, gamma, lognormal, normal) + visualisation + parameters of the fitted distribution.
*To cross check with parameters reported in documentation/report/ journal article, as an implementation check*  
- To do XP: Add probabilistic mean value per distribution  
```{r dist_plot_2, echo = T}
p_2 <- vis_1_param(df = df_pa,
            param = "u_pfs",
            binwidth = NULL,
            type = "density",
            dist = c("norm", "beta", "gamma", "lnorm"),
            user_dist = "beta",
            user_param_1 = 0.8,
            user_param_2 = 0.2,
            user_mean = 0.75)
p_2
```

#### Distributions' parameters & statistical fit
```{r fit_dists, echo = T}
l_dist <- fit_dist(df = df_pa,
                   param = "u_pfs",
                   dist = c("norm", "beta", "gamma", "lnorm"))
l_dist[[1]]
l_dist[[2]]
```

## 3.	Investigate model outputs
### a.	Incremental cost-effectiveness plane & summary
Questions met Karel te bespreken:  
- Interactive plot where you can click on a dot, or select some dots and see which input parameters combination has led to these outputs --> ook mogelijkheid om een bepaalde 'gebied' te selecteren (invoeren) en te zien welke inputs daarbij behoren.  
- Combineren van de plot hierbeneden met de histogrammen van de waarden op de x en y as, of als niet overzichtelijk: met ticks op de axes als er een datapunt is.  

```{r dist_plot_2p, echo = T}
p_3 <- plot_ice(df = df_pa,
                param_1 = "Inc_QALY",
                param_2 = "Inc_Costs",
                wtp = 80000)
p_3
p_3_interact <- ggplotly(p_3)
p_3_interact

summary_ice(df_pa,
           "Inc_QALY",
           "Inc_Costs")
```


- Plot hierboven koppelen aan een graphs van 1 en 2 input parameters. Al gedaan in tentative shiny app voor onderwijs: selectie van punten in de 'input graph' wordt gehighlight in andere plot. Voorbeeld, laatste tabs van volgende shiny app: `shiny::runGitHub("Teaching", "Xa4P", subdir = "Basics/shiny_app_cea/", ref = "main")`.  


### b.	Cost-effectiveness acceptability curve.
```{r ceac, echo = T}
df_ceac <- calculate_ceac(df = df_pa,
                     e_int = "QALY_int",
                     e_comp = "QALY_comp",
                     c_int = "Costs_int",
                     c_comp = "Costs_comp")

plot_ceac(df = df_ceac,
          wtp = "WTP_threshold")
df_ceac
```

### c.	Histogram and density distribution of total and incremental costs and effects.
**Can use the function above!  **

###d.	Convergence graph of outcomes
```{r conv, echo = T}
plot_convergence(df = df_pa,
                 outcome = "iNMB"
                 )
```

## 4.	Investigate relation between inputs and outputs
### Single  

- To do XP: Add R^2^  

```{r fit_metamod_single, echo = T}
lm_rr <- fit_lm_metamodel(df = df_pa,
                          x = "rr",
                          y = "iNMB")
lm_pred <- unlist(predict(lm_rr, data.frame(rr = df_pa$rr)))
df_obs_pred <- data.frame(
  Values = df_pa$rr,
  Observed = df_pa$iNMB,
  Predicted = lm_pred
)
ggplot(data = df_obs_pred, aes(x = Values, y = Observed)) +
  geom_point(shape = 1, colour = "lightgrey") +
  geom_smooth(method = "lm") +
  theme_bw()
plot(lm_rr)
```

### Multiple

- To do XP: Add R^2^  

```{r fit_metamod_mult, echo = T}
lm_full <- fit_lm_metamodel(df = df_pa,
                          x = c("rr", "u_pfs", "u_pd", "c_pfs", "c_pd", "c_thx", "p_pfspd", "p_pfsd", "p_pdd"),
                          y = "iNMB")
lm_pred_full <- predict(lm_full, data.frame(rr = df_pa$rr,
                            u_pfs = mean(df_pa$u_pfs),
                            u_pd = mean(df_pa$u_pd),
                            c_pfs = mean(df_pa$c_pfs),
                            c_pd = mean(df_pa$c_pd),
                            c_thx = mean(df_pa$c_thx),
                            p_pfspd = mean(df_pa$p_pfspd),
                            p_pfsd = mean(df_pa$p_pfsd),
                            p_pdd = mean(df_pa$p_pdd)))

df_obs_pred_full <- data.frame(
  Values = df_pa$rr,
  Observed = df_pa$iNMB,
  Predicted = lm_pred_full
)

ggplot(data = df_obs_pred_full, aes(x = Values, y = Observed)) +
  geom_point(shape = 1, colour = "lightgrey") +
  geom_line(data = df_obs_pred_full, aes(x = Values, y = Predicted), colour = "blue") +
  theme_bw()

plot(lm_full)

df_dsa <- dsa_lm_metamodel(df = df_pa,
                           lm_metamodel = lm_full)
plot_tornado(df = df_dsa,
             df_basecase = df_pa,
             outcome = "iNMB")
```

## 5. Add predictions based on metamodel  



# Other activities/ questions/ to do's
- Two-way sensitivity analysis based on metamodel.  
- Include other functional forms of metamodels  
- Include predictions of outcome based on metamodels  
- Check results of deterministic sensitivity analyses using original model and metamodel.  
- XP to do: Add possibility of having multiple scenarios loaded.  
- Shapley values, zou dat kunnen ? Zou het mogelijk zijn om dat op de originele data set te doen? **KernelExplainer** on this github: https://github.com/slundberg/shap. Of is dit iets? https://github.com/nredell/shapFlex, maar ziet eruit dat je ook een model moet fitten (niet model agnostic)  
- Check whether violin plot have added value  
- KAREL: voor selectie variabelen voor de verschillende functies: gebruik van buttons lijkt me het handigste, wat denk jij?  
- KAREL: is het mogelijk om groepen van variabelen te 'labellen' (dus alle kosten, utiliteiten, probabiliteiten) en dat de Shiny App het als 'groep' ziet en dus dat bepaalde functies (semi-automatisch) uitgevoerd worden op deze groepen variabelen?     
